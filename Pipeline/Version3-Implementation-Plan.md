# Version 3 Implementation Plan

**Goal:** Boost hackathon score from 82-85 to 90+ by adding AI-powered narration and ITDR threat detection

**Target Score Breakdown:**
- Current: 82-85/100
- After V3: 90-92/100
- Improvement 1 (AI Narration): +5 points
- Improvement 2 (ITDR Live Use Case): +3 points

---

## Improvement 1: AI-Powered Narration (+5 points)

### Overview
Replace pre-written templates with real-time Claude API interpretations of security events, generating dynamic business outcomes and explanations.

### Current State
- Static templates in `client/src/components/AccessPipeline.jsx` (`getNodeEventLogs` function)
- Pre-written business outcome badges in use case cards
- No AI at runtime (only AI-assisted development)

### Target State
- Claude API interprets raw Okta events in real-time
- Generates contextual "why this matters" explanations
- Creates dynamic business outcome statements
- Shows AI-powered insights badge on cards

### Implementation Tasks

#### Phase 1A: Backend - Claude API Integration
**Files to modify:** `server/index.js`, `server/package.json`

- [ ] **Task 1.1:** Install Anthropic SDK
  ```bash
  cd server && npm install @anthropic-ai/sdk
  ```
- [ ] **Task 1.2:** Add environment variable for API key
  - Create `server/.env` with `ANTHROPIC_API_KEY=sk-...`
  - Add `dotenv` package: `npm install dotenv`
  - Load in server: `require('dotenv').config();`
- [ ] **Task 1.3:** Create Claude client module
  - New file: `server/services/claudeService.js`
  - Export `interpretEvent(eventData)` function
  - Export `generateBusinessOutcome(eventData)` function
  - Use Claude 4.5 Haiku for speed and cost efficiency
  - Prompt engineering: "You are an identity security expert. Explain this Okta event in 1-2 sentences focusing on business value..."
- [ ] **Task 1.4:** Create event interpretation cache
  - In-memory cache (Map) keyed by event UUID
  - TTL: 1 hour (prevent duplicate API calls)
  - Add `interpretedEvents` Map to server state
- [ ] **Task 1.5:** Add `/interpret-event` POST endpoint
  - Accepts: `{ eventUUID, eventData, nodeId, useCase }`
  - Returns: `{ interpretation, businessOutcome, generatedAt }`
  - Check cache first, call Claude if miss
  - Broadcast interpretation to WebSocket clients

#### Phase 1B: Frontend - AI Interpretation Display
**Files to modify:** `client/src/components/AccessPipeline.jsx`, `client/src/components/UseCaseCard.jsx`

- [ ] **Task 1.6:** Add AI interpretation state to AccessPipeline
  - New state: `aiInterpretations` (Map of nodeId ‚Üí interpretation)
  - New state: `isGeneratingAI` (loading indicator)
- [ ] **Task 1.7:** Create "Ask Claude" button in event drawer
  - Position: Below raw log toggle
  - Icon: Sparkles ‚ú® or robot ü§ñ
  - Click handler: `handleGenerateInterpretation(selectedNode)`
- [ ] **Task 1.8:** Implement interpretation fetch logic
  ```javascript
  const handleGenerateInterpretation = async (nodeId) => {
    setIsGeneratingAI(true);
    const response = await fetch(`${API_URL}/interpret-event`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        eventData: rawData,
        nodeId,
        useCase: getActiveUseCase(nodeId)
      })
    });
    const data = await response.json();
    setAiInterpretations(prev => ({ ...prev, [nodeId]: data }));
    setIsGeneratingAI(false);
  };
  ```
- [ ] **Task 1.9:** Display AI interpretation in drawer
  - Separate section with blue/purple gradient background
  - Title: "ü§ñ AI Insights"
  - Show interpretation text with typewriter effect (optional)
  - Show business outcome badge below
  - Display "Generated by Claude 4.5 Haiku" attribution
- [ ] **Task 1.10:** Add AI badge to UseCaseCard
  - When card completes with AI interpretation, show "AI Analyzed" badge
  - Purple gradient pill next to business outcome
  - Click to view interpretation

#### Phase 1C: Prompt Engineering & Testing
**New file:** `server/prompts/eventInterpretation.js`

- [ ] **Task 1.11:** Create prompt templates for each node type
  - Security Evaluations: Focus on threat prevention
  - Integrations: Focus on workflow efficiency
  - Unified Outcomes: Focus on compliance/risk reduction
- [ ] **Task 1.12:** Test interpretations with sample events
  - MFA Login: Should emphasize phishing resistance
  - Group Assignment: Should emphasize automation benefits
  - Device Posture: Should emphasize zero trust
- [ ] **Task 1.13:** Add error handling
  - Fallback to static templates if Claude API fails
  - Show "AI interpretation unavailable" message
  - Log errors for debugging

**Estimated Time:** 4-6 hours
**Dependencies:** Anthropic API key, Claude 4.5 Haiku access

---

## Improvement 2: ITDR Threat Detection Live Use Case (+3 points)

### Overview
Integrate colleague's SSF-Transmitter to simulate real-time security threats, triggering ITDR detection and remediation workflows in Project Athena.

### External Repository
**Source:** https://github.com/Zantonse/SSF-Transmitter
**Project:** Okta SSF Visual - Security Event Token (SET) transmitter for Identity Threat Protection

### Architecture
```
SSF-Transmitter (Next.js)    ‚Üí    Okta ITP    ‚Üí    Project Athena (Dashboard)
    ‚Üì                                 ‚Üì                    ‚Üì
Generate fake threats          Process via          Display ITDR cards
(CrowdStrike, Zscaler)        Entity Risk Policies  with live events
    ‚Üì                                 ‚Üì                    ‚Üì
Sign & send SETs             Trigger Event Hooks    Animated checkmarks
```

### Integration Strategy
**Option A:** Embed SSF-Transmitter UI in Project Athena (Recommended)
- Iframe or React component import
- User generates threats from within dashboard
- Immediate visual feedback loop

**Option B:** Standalone + API Bridge
- SSF-Transmitter runs separately
- Project Athena listens for resulting Okta events
- Requires coordination between two apps

### Implementation Tasks

#### Phase 2A: Repository Analysis & Setup
- [ ] **Task 2.1:** Clone colleague's repository locally
  ```bash
  cd /tmp
  git clone https://github.com/Zantonse/SSF-Transmitter.git
  cd SSF-Transmitter/okta-ssf-visual
  ```
- [ ] **Task 2.2:** Review codebase structure
  - Identify key components: Provider selector, event buttons, API routes
  - Identify dependencies: jose, Next.js 16, TypeScript
  - Identify configuration: JWKS URL, Okta org settings
- [ ] **Task 2.3:** Understand SET transmission flow
  - How are events triggered (button clicks)?
  - How are SETs signed (jose library)?
  - Where are they sent (Okta ITP endpoint)?
  - What response format?
- [ ] **Task 2.4:** Test SSF-Transmitter standalone
  - Run `npm install && npm run dev`
  - Generate test SET
  - Verify Okta receives it

#### Phase 2B: Extract Reusable Components
**Goal:** Create a simplified threat simulator for Project Athena

- [ ] **Task 2.5:** Extract provider definitions
  - Copy event types: CrowdStrike, Zscaler, Palo Alto, Custom
  - Simplify to 4-6 most impactful events
  - Create: `client/src/data/threatEvents.js`
  ```javascript
  export const THREAT_EVENTS = [
    {
      id: 'crowdstrike-malware',
      provider: 'CrowdStrike Falcon',
      event: 'Malware Detection',
      description: 'Endpoint detected malicious file execution',
      riskLevel: 'high'
    },
    // ... more events
  ];
  ```
- [ ] **Task 2.6:** Extract SET signing logic
  - Copy JWT signing function from SSF-Transmitter
  - Create: `server/services/ssfService.js`
  - Export `generateAndSendSET(eventType, userEmail)` function
  - Include JWKS key generation (or use pre-configured keys)
- [ ] **Task 2.7:** Create threat transmission API endpoint
  - New endpoint: `POST /transmit-threat`
  - Accepts: `{ provider, eventType, targetUser }`
  - Signs SET using jose library
  - Sends to Okta ITP
  - Returns: `{ success, setId, transmittedAt }`

#### Phase 2C: Build Threat Simulator UI
**Files to modify:** `client/src/components/GenerateThreats.jsx`

- [ ] **Task 2.8:** Replace placeholder with threat grid
  - Provider selector dropdown (CrowdStrike, Zscaler, Palo Alto, Custom)
  - Event button grid (4-6 buttons per provider)
  - Target user input (email or select from recent logins)
- [ ] **Task 2.9:** Style threat buttons
  - Red gradient background for high-risk events
  - Yellow gradient for medium-risk
  - Icon for each event type (shield, alert triangle, etc.)
  - Hover effect with event description
- [ ] **Task 2.10:** Implement transmission handler
  ```javascript
  const handleTransmitThreat = async (eventId) => {
    const event = THREAT_EVENTS.find(e => e.id === eventId);
    const response = await fetch(`${API_URL}/transmit-threat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        provider: event.provider,
        eventType: event.event,
        targetUser: selectedUser
      })
    });
    // Show success toast notification
  };
  ```
- [ ] **Task 2.11:** Add activity log
  - Show last 10 transmitted threats
  - Display: timestamp, event type, target user, status
  - Real-time updates via WebSocket

#### Phase 2D: Backend - Event Hook Receiver for ITP
**Files to modify:** `server/index.js`

- [ ] **Task 2.12:** Add ITDR use case state
  ```javascript
  useCaseStates = {
    mfaLogin: { completed: false, data: null },
    groupAssignment: { completed: false, data: null },
    itdrThreatDetection: { completed: false, data: null } // NEW
  };
  ```
- [ ] **Task 2.13:** Handle ITP-related Okta events
  - Event types: `policy.evaluate_sign_on`, `user.session.access_admin_app`, `user.risk.change`
  - Add to webhook handler in `/webhook` endpoint
  - Correlate SET transmission with resulting Okta response
- [ ] **Task 2.14:** Create ITDR event processor
  - New function: `processItdrEvent(oktaEvent)`
  - Extract: threat type, risk level, user affected, remediation action
  - Generate event log entries for Pipeline View
  - Broadcast `USE_CASE_COMPLETED` for `itdrThreatDetection`

#### Phase 2E: Frontend - ITDR Cards & Pipeline Integration
**Files to modify:** `client/src/components/Dashboard.jsx`, `client/src/components/AccessPipeline.jsx`

- [ ] **Task 2.15:** Update ITDR pillar section in Dashboard
  - Replace "Coming Soon" cards with live cards
  - Add "Automated Threat Response" card
  - Add "Risk-Based Access Policies" card
  - Add "Continuous Risk Assessment" card
- [ ] **Task 2.16:** Create use case card for ITDR
  - Title: "Automated Threat Response"
  - Description: "Detect and respond to identity threats in real-time"
  - Business Outcomes:
    - üõ°Ô∏è **Security Improved:** Automated response to credential compromise
    - ‚ö° **Response Time:** Instant session revocation upon threat detection
- [ ] **Task 2.17:** Add ITDR nodes to Pipeline View
  - Option 1: Extend existing pipeline with ITDR branch
  - Option 2: Add separate "Threat Detection" layer above main flow
  - Show threat event ‚Üí risk evaluation ‚Üí remediation action flow
- [ ] **Task 2.18:** Update USE_CASE_NODE_MAP
  ```javascript
  itdrThreatDetection: [
    'needAccess', 'verifyIdentity', 'threatDetection',
    'riskEvaluation', 'remediationAction'
  ]
  ```
- [ ] **Task 2.19:** Create event logs for ITDR nodes
  - Example logs:
    - "CrowdStrike alert received: Malware detected on endpoint"
    - "User risk level elevated from LOW to HIGH"
    - "Session revoked automatically via Entity Risk Policy"
    - "Admin notified of security incident"

#### Phase 2F: Configuration & Testing
- [ ] **Task 2.20:** Configure Okta ITP Stream
  - Set up Security Event Token (SET) receiver in Okta
  - Register JWKS URL for signature verification
  - Create Entity Risk Policies to process SETs
  - Configure Event Hooks to send ITP events to Project Athena
- [ ] **Task 2.21:** End-to-end testing
  - Generate threat from `/generate-threats` page
  - Verify SET sent to Okta ITP
  - Verify Event Hook received by Project Athena
  - Verify ITDR card completes with animated checkmark
  - Verify Pipeline View highlights threat detection nodes
- [ ] **Task 2.22:** Add demo instructions
  - Update README with ITDR demo workflow
  - Add screenshots of threat simulator
  - Document Okta ITP configuration steps

**Estimated Time:** 6-8 hours (includes Okta ITP setup)
**Dependencies:** Access to colleague's repo, Okta org with ITP enabled, JWKS hosting

---

## Phase 3: Polish & Demo Prep

### General Enhancements
- [ ] **Task 3.1:** Add loading states for AI interpretations
  - Skeleton loader with pulsing animation
  - "Analyzing event..." text
- [ ] **Task 3.2:** Add success notifications
  - Toast notifications for threat transmissions
  - "Threat generated successfully" with event name
- [ ] **Task 3.3:** Improve error handling
  - Graceful fallbacks if Claude API fails
  - Clear error messages if SSF transmission fails
  - Retry logic for transient failures
- [ ] **Task 3.4:** Add "AI Powered" badge to Header
  - Show when AI interpretations are available
  - Purple gradient badge: "ü§ñ AI Insights Enabled"
- [ ] **Task 3.5:** Update stats banner
  - Add count: "X Threats Detected"
  - Add count: "X AI Insights Generated"
- [ ] **Task 3.6:** Performance optimization
  - Debounce AI interpretation requests
  - Cache Claude responses in browser sessionStorage
  - Lazy load threat simulator components

### Documentation Updates
- [ ] **Task 3.7:** Update README.md
  - Add Version 3.0 section with new features
  - Add AI narration demo workflow
  - Add ITDR threat detection demo workflow
  - Add environment variable setup instructions
- [ ] **Task 3.8:** Create demo script
  - New file: `DEMO_SCRIPT.md`
  - Step-by-step guide for judges
  - Highlight "wow" moments (AI insights appearing, threats triggering responses)
- [ ] **Task 3.9:** Add architecture diagram
  - Show data flow: SSF-Transmitter ‚Üí Okta ‚Üí Project Athena
  - Show Claude API integration points
  - Use Mermaid or diagram tool

**Estimated Time:** 2-3 hours

---

## Summary & Checkpoints

### Total Estimated Time: 12-17 hours
- **Improvement 1 (AI Narration):** 4-6 hours
- **Improvement 2 (ITDR):** 6-8 hours
- **Polish & Demo Prep:** 2-3 hours

### Implementation Order (Recommended)
1. **Start with Improvement 1** (AI Narration)
   - Faster to implement, immediate visual impact
   - Tests Claude API integration early
   - Can demo standalone without ITDR
2. **Then Improvement 2** (ITDR)
   - More complex, requires external repo integration
   - Depends on Okta ITP configuration
   - Builds on AI narration (can interpret threat events)
3. **Finish with Polish**
   - Refine based on testing feedback
   - Optimize for demo presentation

### Pause Checkpoints
- ‚úã **After Task 1.5:** Test Claude API endpoint manually (curl or Postman)
- ‚úã **After Task 1.10:** Demo AI interpretation in Pipeline View to user
- ‚úã **After Task 2.4:** Confirm SSF-Transmitter works standalone
- ‚úã **After Task 2.11:** Demo threat simulator UI to user
- ‚úã **After Task 2.21:** Full end-to-end ITDR demo with user

### Success Criteria
- [ ] AI interpretations appear within 2 seconds of clicking "Ask Claude"
- [ ] ITDR card completes when threat is transmitted and detected
- [ ] Pipeline View highlights threat detection nodes in real-time
- [ ] Demo runs smoothly without manual intervention
- [ ] All features work in GitHub Codespace environment

### Risk Mitigation
- **Risk:** Claude API rate limits or latency
  - **Mitigation:** Cache interpretations, use Haiku for speed, add fallback to static templates
- **Risk:** SSF-Transmitter integration too complex
  - **Mitigation:** Extract minimal viable components, simplify to 3-4 threat types only
- **Risk:** Okta ITP configuration issues
  - **Mitigation:** Document exact steps, test in sandbox org first, have fallback demo data
- **Risk:** Time constraints (hackathon deadline)
  - **Mitigation:** Prioritize Improvement 1 (AI) over Improvement 2 (ITDR) if needed

---

## Files to Create/Modify

### New Files
- `server/.env` - Environment variables (API keys)
- `server/services/claudeService.js` - Claude API integration
- `server/services/ssfService.js` - SSF/SET signing logic
- `server/prompts/eventInterpretation.js` - AI prompt templates
- `client/src/data/threatEvents.js` - Threat event definitions
- `DEMO_SCRIPT.md` - Judge demonstration guide
- `ARCHITECTURE.md` - System architecture diagram

### Files to Modify
- `server/index.js` - Add `/interpret-event`, `/transmit-threat` endpoints, ITDR event handling
- `server/package.json` - Add @anthropic-ai/sdk, jose, dotenv
- `client/src/App.jsx` - Add `itdrThreatDetection` to use case state
- `client/src/components/AccessPipeline.jsx` - Add AI interpretation UI, ITDR nodes
- `client/src/components/Dashboard.jsx` - Update ITDR pillar with live cards
- `client/src/components/GenerateThreats.jsx` - Replace placeholder with threat simulator
- `client/src/components/Header.jsx` - Add "AI Powered" badge
- `client/src/components/StatsBanner.jsx` - Add threat count, AI insight count
- `README.md` - Add Version 3.0 section, AI & ITDR setup instructions

### Unchanged
- `client/src/components/PipelineDiagram.jsx` - May add nodes, but core structure stable
- `client/src/hooks/useWebSocket.js` - No changes needed
- All other existing components remain stable

---

## Next Steps

**To proceed:**
1. **User decision:** Which improvement to implement first? (Recommended: Improvement 1 - AI Narration)
2. **User action:** Provide Anthropic API key for Claude integration
3. **User action:** Confirm access to Okta org with ITP enabled (for Improvement 2)
4. **User action:** Grant access to colleague's SSF-Transmitter repo (if private)

**Questions for user:**
- Do you have an Anthropic API key for Claude 4.5 Haiku?
- Does your Okta org have Identity Threat Protection (ITP) enabled?
- Is the SSF-Transmitter repository public or will colleague grant access?
- What is the hackathon deadline? (To prioritize features if time-constrained)
- Should we commit after each improvement, or one final commit?
